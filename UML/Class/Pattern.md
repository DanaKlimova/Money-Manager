## Observer
На диаграмме классов изображен паттерн проектирования Observer. Данный паттерн является поведенческим. 
Он создает механизм подписки, благодаря которому одни объекты могут следить и реагировать на события, происходящие в других объектах.
Применительно к моему проекту, можно выделить участников:
<ul>
<li>Publisher - данный интерфейс не был спроектирован.</li>
<li>Subscriber - это интерфейс, определяющий поведение подписчика.</li>
<li>ConcretePublisher - - это controllers: CashVoucherController, MainController.</li>
<li>ConcreteSubscriber - это views; CashVoucherView, MainView.</li>
</ul>
Данные для отображения на страницах CashVoucherView и MainView находятся в объектах CashVoucherController и MainController, поэтому чтобы следить за состоянием данных в этих объектах используется паттерн Observer. Данные в CashVoucherController и MainController поступают из БД, и когда они обновляются, то эти объеты уведомляют CashVoucherView и MainView, которые отображают актуальные данные.

## Проблема
Проблема заключается в необходимости поддержания согласованного состояния объектов. Паттерн наблюдатель позволяет решить эту проблему с помощью
ключевых объектов: подписчик и издатель. Издатель публикует уведомления и рассылает их, не имея информации о том, какие объекты являются его подписчиками.

## Участники
<ul>
<li>Publisher - издатель; располагает информацией за о своих наблюдателях.</li>
<li>Subscriber - подписчик; определяет интерфейс обновления для объектов, которые должны быть уведомлены об изменении издателя.</li>
<li>ConcretePublisher - конкретный издатель; сохраняет состояние, представляющее интерес для конкретного подписчика.</li>
<li>ConcreteSubscriber - конкретный наблюдатель; хранит ссылку на объект класса ConcretePublisher, сохраняет данные, которые должны быть согласованы
с данными издателя, реализует интерфейс обновления, определнный в класе Subscriber.</li>
</ul>

## Структура
<ul>
  <li>Издатель владеет внутренним состоянием, изменение которого интересно отслеживать подписчикам. Издатель содержит механизм подписки: список подписчиков и методы подписки/отписки.</li>

  <li>Когда внутреннее состояние издателя меняется, он оповещает своих подписчиков. Для этого издатель проходит по списку подписчиков и вызывает их метод оповещения, заданный в общем интерфейсе подписчиков.</li>

  <li>Подписчик определяет интерфейс, которым пользуется издатель для отправки оповещения. В большинстве случаев для этого достаточно единственного метода.</li>

  <li>Конкретные подписчики выполняют что-то в ответ на оповещение, пришедшее от издателя. Эти классы должны следовать общему интерфейсу подписчиков, чтобы издатель не зависел от конкретных классов подписчиков.</li>

  <li>По приходу оповещения подписчику нужно получить обновлённое состояние издателя. Издатель может передать это состояние через параметры метода оповещения. Более гибкий вариант — передавать через параметры весь объект издателя, чтобы подписчик мог сам получить требуемые данные. Как вариант, подписчик может постоянно хранить ссылку на объект издателя, переданный ему в конструкторе.</li>

  <li>Клиент создаёт объекты издателей и подписчиков, а затем регистрирует подписчиков на обновления в издателях.</li>
  </ul>
